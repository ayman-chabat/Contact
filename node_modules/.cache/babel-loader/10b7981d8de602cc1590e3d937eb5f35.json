{"ast":null,"code":"import { sync } from '../../frameloop/index.mjs';\nimport { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearStoreId } from './store-id.mjs';\nfunction handoffOptimizedAppearAnimation(id, name, value) {\n  var _window = window,\n    MotionAppearAnimations = _window.MotionAppearAnimations;\n  var animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  var animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\n  if (animation) {\n    var sampledTime = performance.now();\n    /**\n     * Resync handoff animation with optimised animation.\n     *\n     * This step would be unnecessary if we triggered animateChanges() in useEffect,\n     * but due to potential hydration errors we currently fire them in useLayoutEffect.\n     *\n     * By the time we're safely ready to cancel the optimised WAAPI animation,\n     * the main thread might have been blocked and desynced the two animations.\n     *\n     * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\n     */\n    sync.update(function () {\n      if (value.animation) {\n        value.animation.currentTime = performance.now() - sampledTime;\n      }\n    });\n    /**\n     * We allow the animation to persist until the next frame:\n     *   1. So it continues to play until Framer Motion is ready to render\n     *      (avoiding a potential flash of the element's original state)\n     *   2. As all independent transforms share a single transform animation, stopping\n     *      it synchronously would prevent subsequent transforms from handing off.\n     */\n    sync.render(function () {\n      MotionAppearAnimations.delete(animationId);\n      /**\n       * Animation.cancel() throws so it needs to be wrapped in a try/catch\n       */\n      try {\n        animation.cancel();\n      } catch (e) {}\n    });\n    return animation.currentTime || 0;\n  } else {\n    return 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":null,"metadata":{},"sourceType":"module"}